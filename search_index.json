[["_main.html", "Spotify API Einführung Vorwort 1 Setup 1.1 Einrichten der API 1.2 Libraries 1.3 Authorisierung 2 Playlist Analysen 2.1 Datenbeschaffung 2.2 Datenbereinigung 2.3 Explorative Datenanalyse 3 Artist Analysen 3.1 Related Artists 3.2 Artist Vergleich 4 Album Analysen 4.1 Album Vergleich 5 Weitere Ressourcen", " Spotify API Einführung Autor: Jonathan Schuster Kontakt: schuster.jonathan95@gmail.com 2021-11-24 Vorwort Dieses Tutorial zeigt am Beispiel von Spotify wie eine API genutzt werden kann, um Daten zu sammeln, zu analysieren und darzustellen. Erleichtert wird dies durch das Package spotifyr. Hilfreiche Dokumentationen sind hier zu finden: Spotify API Dokumentation - für Hintergrundinformationen, etc. Spotifyr Package Dokumentation - für eine Übersicht der Funktionen, Befehle und Parameter. 1 Setup 1.1 Einrichten der API Um sich mit der Spotify API verbinden zu können, werden eine sogenannte SPOTIFY_CLIENT_ID und ein SPOTIFY_CLIENT_SECRET benötigt, die Spotify im Portal für Entwickler (Spotify for Developers) zur Verfügung stellt. Mit der Identifikationsnummer (Client ID) und dem geheimen, persönlichen Clientschlüssel (Secret) wird der Zugriff auf die API von Spotify dem API-Nutzer und seiner Anwendung zugeordnet. Um ID und Clientschlüssel zu erhalten, müssen wir uns zunächst im Portal unter https://developer.spotify.com/dashboard/login anmelden und unseren Zugang einrichten. Dies ist entweder mit einem bereits bestehenden Spotify Konto möglich oder durch die Registrierung eines neuen (kostenfreien) Spotify Kontos. Nach erfolgreicher Anmeldung und Bestätigung der Vereinbarungen von Spotify erscheint ein Dashboard mit einer Übersicht über die von uns erstellten Apps im Portal. Da wir jedoch noch keine App erstellt haben, müssen wir dies nun über CREATE AN APP machen. Im sich dann öffnenden Fenster müssen wir der Anwendung einen Namen und eine Beschreibung geben, den Bestimmungen von Spotify zustimmen und die Anwendung anschließend erstellen. Damit erhalten wir ein weiteres Dashboard - diesmal für unsere neu erstellte Anwendung. Links über dem Dashboard finden wir so nun unsere Client ID und unter “Show Client Secret” unser Client Secret, also unseren persönlichen Zugangsschlüssel. Beide werden wir später in R einfügen müssen, um eine Verbindung zu unserer Anwendung und damit der Spotify API aufzubauen. Beide sind prinzipiell vertraulich zu behandeln, da mit ihnen praktisch jeder über die auf unser Konto registrierte Anwendung auf die Spotify API zugreifen kann und damit theoretisch auch Handlungen durchführen könnte, die den Nutzungsbedingungen von Spotify widersprechen. Bevor wir in R starten können, ist zudem noch eine weitere Einstellung nötig. Da es für bestimmte Funktionen und Anwendungen erforderlich ist, sich bei Spotify einzuloggen, muss eine Rückverbindung zwischen unserer Anwendung und der API hergestellt werden. Um diese einzurichten, müssen wir unter EDIT SETTINGS die Einstellungen öffnen. Anschließend müssen wir in den Einstellungen die Adresse: http://localhost:1410/ in das Feld Redirect URIs eingetragen. Anschließend sind die Einstellungen zu speichern. 1.2 Libraries Nun können wir unser R-Projekt anlegen und die für unser Projekt notwendigen Libraries laden. Diese Libraries werden im Folgenden verwendet: spotifyr - um die Verbindung zu unserer Spotify-Anwendung herzustellen und Daten über die im Package enthaltenen Funktionen zu erhalten ggplot2 - um Diagramme anzufertigen und unsere Daten zu visualisieren dplyr - um unseren Datensatz gruppieren und filtern zu können purrr - wird in der Datenbereinigung verwendet library(spotifyr) library(ggplot2) library(dplyr) library(purrr) 1.3 Authorisierung Nun können wir eine Verbindung zu unserer Anwendung und damit der Spotify API herstellen. Durch den folgenden Code und mit unserer Client ID sowie unserem Client Secret können wir unseren Zugang authorisieren. Beim ersten Ausführen der Funktion get_spotify_authorization_code() öffnet sich ein neues Fenster, in dem unser Zugriff bestätigt werden muss. Anschließend ist die Verbindung zu unserer Schnittstelle hergestellt. Sys.setenv(SPOTIFY_CLIENT_ID = &#39;77f1d2129ed4430284eb4f31e9029b37&#39;) Sys.setenv(SPOTIFY_CLIENT_SECRET = &#39;b336e77068ca481ab8c3bfb5fc06e37f&#39;) get_spotify_authorization_code() Nun ist die Verbindung hergestellt und wir können die Funktionen des spotifyr packages nutzen, um Daten zu sammeln. Hinweis: Die Anwendung mit Client ID und Client Secret aus dem hier dargestellten Code wird voraussichtlich in näherer Zukunft aus Sicherheitsgründen abgeschaltet. Eigene ID und Secret sollten stattdessen verwendet werden. 2 Playlist Analysen Mit der nun hergestellten Verbindung können wir jegliche Funktionen des spotifyr Packages nutzen und beispielsweise Daten zu Künstlern, Alben, Playlisten oder Labels von Spotify abfragen. Eine Übersicht zu den möglichen Funktionen ist in der spotifyr Dokumentation zu finden: Spotifyr Package Dokumentation - für eine Übersicht der Funktionen, Befehle und Parameter. Playlisten sind heutzutage das zentrale Element in der Art und Weise wie Musik konsumiert wird. Ganz egal ob es sich dabei um hauseigene, von Spotify kuratierte Playlisten oder um von anderen Nutzern oder uns selbst erstellte Playlisten handelt, spotifyr ermöglicht uns den Zugang zu unterschiedlichsten Daten über diese Playlisten. Diese Daten erhalten wir unter anderem durch folgende Funktionen: get_category_playlists() - gibt eine Liste von Playlisten, mit einer bestimmten Kategorie getagged werden aus get_playlist_cover_image() - lädt das Cover-Bild einer Playlist get_playlist_tracks() - lädt Details zu den Songs in einer Playlist get_playlist_audio_features() - lädt Meta-Daten sowie Audio-Analyse-Daten der Songs einer Playlist 2.1 Datenbeschaffung Um eine Playlist zu analysieren, benötigen wir nun lediglich die Playlist URI, die sich im Link einer jeden Playlist befindet und den Namen des Profils, welches die Playlist erstellt hat. Dazu können wir im Browser oder in der Spotify Desktop-App über die drei kleinen Punkte in der Menüleiste der Playlist zum Link gelangen. Ich habe mich hier für die “Top 50 - Global” Playlist von Spotify entschieden. Der vollständige Link zur Playlist ist: https://open.spotify.com/playlist/37i9dQZEVXbMDoHDwVN2tF?si=95eadb888fe644fc Aus dieser URL kann ich nun die URI kopieren. Sie setzt sich aus den Zeichen ab playlist/ bis zum ? zusammen. Also aus der hier markierten Zeichenfolge: …open.spotify.com/playlist/37i9dQZEVXbMDoHDwVN2tF?si=95eadb888fe644fc Zusammen mit dem Namen des Profils welches die Playlist erstellt hat (in diesem Fall Spotify), können wir nun ein Dataframe mit dem Titel playlist_dataframe erstellen und die Daten der Playlist über die Funktion get_playlist_audio_features() abfragen. Wichtiger Hinweis: Da wir mit der “Top 50 - Global” Playlist eine sich täglich aktualisierende Playlist ausgewählt haben, können die Ergebnisse und Songs beim “selber ausprobieren” von denen des Tutorials abweichen. playlist_username &lt;- &#39;Spotify&#39; playlist_uris &lt;- c(&#39;37i9dQZEVXbMDoHDwVN2tF&#39;) playlist_dataframe &lt;- get_playlist_audio_features(playlist_username, playlist_uris) Über die Funktion colnames() können wir uns nun anschauen, welche Variablen und damit welche Informationen dieser Datensatz enthält. Neben typischen Meta-Daten wie dem Songnamen in der Spalte track.name, der URI der einzelnen Songs in der Spalte track.uri oder dem Tag, an dem der Song der Playlist hinzugefügt wurde, in der Spalte added_at, beinhaltet unser Datensatz unter Anderem Audioanalysen, Links und Informationen über die Länder in denen der Song verfügbar ist. colnames(playlist_dataframe) ## [1] &quot;playlist_id&quot; &quot;playlist_name&quot; ## [3] &quot;playlist_img&quot; &quot;playlist_owner_name&quot; ## [5] &quot;playlist_owner_id&quot; &quot;danceability&quot; ## [7] &quot;energy&quot; &quot;key&quot; ## [9] &quot;loudness&quot; &quot;mode&quot; ## [11] &quot;speechiness&quot; &quot;acousticness&quot; ## [13] &quot;instrumentalness&quot; &quot;liveness&quot; ## [15] &quot;valence&quot; &quot;tempo&quot; ## [17] &quot;track.id&quot; &quot;analysis_url&quot; ## [19] &quot;time_signature&quot; &quot;added_at&quot; ## [21] &quot;is_local&quot; &quot;primary_color&quot; ## [23] &quot;added_by.href&quot; &quot;added_by.id&quot; ## [25] &quot;added_by.type&quot; &quot;added_by.uri&quot; ## [27] &quot;added_by.external_urls.spotify&quot; &quot;track.artists&quot; ## [29] &quot;track.available_markets&quot; &quot;track.disc_number&quot; ## [31] &quot;track.duration_ms&quot; &quot;track.episode&quot; ## [33] &quot;track.explicit&quot; &quot;track.href&quot; ## [35] &quot;track.is_local&quot; &quot;track.name&quot; ## [37] &quot;track.popularity&quot; &quot;track.preview_url&quot; ## [39] &quot;track.track&quot; &quot;track.track_number&quot; ## [41] &quot;track.type&quot; &quot;track.uri&quot; ## [43] &quot;track.album.album_type&quot; &quot;track.album.artists&quot; ## [45] &quot;track.album.available_markets&quot; &quot;track.album.href&quot; ## [47] &quot;track.album.id&quot; &quot;track.album.images&quot; ## [49] &quot;track.album.name&quot; &quot;track.album.release_date&quot; ## [51] &quot;track.album.release_date_precision&quot; &quot;track.album.total_tracks&quot; ## [53] &quot;track.album.type&quot; &quot;track.album.uri&quot; ## [55] &quot;track.album.external_urls.spotify&quot; &quot;track.external_ids.isrc&quot; ## [57] &quot;track.external_urls.spotify&quot; &quot;video_thumbnail.url&quot; ## [59] &quot;key_name&quot; &quot;mode_name&quot; ## [61] &quot;key_mode&quot; 2.2 Datenbereinigung Bevor erste Analysen angefertigt werden können, sollte zunächst ein genauerer Blick auf den vorliegenden Datensatz geworfen werden. Um sehen zu können, welche die ersten 5 Songs in der Playlist sind und von welchen Künstler diese Songs können wir folgenden Befehl ausführen: playlist_dataframe[1:5, c(&quot;track.name&quot;,&quot;track.artists&quot;)] ## # A tibble: 5 x 2 ## track.name track.artists ## &lt;chr&gt; &lt;list&gt; ## 1 Easy On Me &lt;df[,6] [1 × 6… ## 2 STAY (with Justin Bieber) &lt;df[,6] [2 × 6… ## 3 Oh My God &lt;df[,6] [1 × 6… ## 4 All Too Well (10 Minute Version) (Taylor&#39;s Version) (From The… &lt;df[,6] [1 × 6… ## 5 INDUSTRY BABY (feat. Jack Harlow) &lt;df[,6] [2 × 6… Hier stellen wir jedoch fest, dass der Eintrag in der Spalte track.artists für jeden Song aus einem weiteren Dataframe besteht. Zusätzlich sehen wir, dass die Dimensionen dieser Dataframes variieren. Bei genauerer Betrachtung eines solchen Eintrags können wir jedoch feststellen, dass in diesen Dataframes neben dem Künstlernamen auch die URL zum Profil des Künstlers, seine ID und weitere Informationen verborgen sind. Um unseren Datensatz besser aufzubereiten, können wir mit der Funktion map_chr() aus der Library purr() für jede Zeile in unserem Datensatz den ersten Eintrag in der Variable name extrahieren und einer neuen Spalte mit dem Titel main_artist hinzufügen. So können wir nun neben dem Songtitel direkt den Künstlernamen des in den Songdaten zuerst genannten Künstlers erhalten. playlist_dataframe$main_artist &lt;- map_chr(playlist_dataframe$track.artists, function(x) x$name[1]) playlist_dataframe[1:5, c(&quot;track.name&quot;,&quot;main_artist&quot;)] ## # A tibble: 5 x 2 ## track.name main_artist ## &lt;chr&gt; &lt;chr&gt; ## 1 Easy On Me Adele ## 2 STAY (with Justin Bieber) The Kid LAR… ## 3 Oh My God Adele ## 4 All Too Well (10 Minute Version) (Taylor&#39;s Version) (From The Va… Taylor Swift ## 5 INDUSTRY BABY (feat. Jack Harlow) Lil Nas X In der Spalte track.album.release_date können wir das Erscheinungsdatum der Songs einsehen. Da die in dieser Spalte enthaltenen Werte jedoch das Format character haben und wir uns in den folgenden Analysen eher für das Erscheinungsjahr und nicht für den genauen Tag interessieren, können wir eine neue Spalte für das Erscheinungsjahr anlegen und das Datum in das Format “%Y” konvertieren. Wir nennen diese Spalte release_year. playlist_dataframe$release_year &lt;- format(as.Date(playlist_dataframe$track.album.release_date), format=&quot;%Y&quot;) playlist_dataframe[1:5, c(&quot;track.name&quot;,&quot;main_artist&quot;,&quot;release_year&quot;)] ## # A tibble: 5 x 3 ## track.name main_artist release_year ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Easy On Me Adele 2021 ## 2 STAY (with Justin Bieber) The Kid LAR… 2021 ## 3 Oh My God Adele 2021 ## 4 All Too Well (10 Minute Version) (Taylor&#39;s Version)… Taylor Swift 2021 ## 5 INDUSTRY BABY (feat. Jack Harlow) Lil Nas X 2021 Aufgrund des Umfangs unseres Datensatzes besteht außerdem Kürzungspotenzial. Für weitere Analysen könnte man sich nun einen weiteren Datensatz einrichten, der nur die zu untersuchenden Variablen erhält. Um hier jedoch Spielraum für Kreativität zu lassen, sehen wir an dieser Stelle davon ab. 2.3 Explorative Datenanalyse 2.3.1 Erscheinungsjahre Da wir bereits eine Spalte für das Erscheinungsjahr erstellt haben, können wir uns nun anschauen, wieviele Songs unserer Playlist aus welchen Jahren stammen. Für die Darstellung nutzen wir hier die Library ggplot2. Mit den Funktionen labs() und geom_text() können wir das Diagramm beschriften und uns die Summe der Songs pro Jahr über jedem Balken anzeigen lassen. library(ggplot2) release_year_plot &lt;- ggplot(playlist_dataframe, aes(x=release_year)) + geom_bar() + labs(title = &quot;Songs pro Erscheinungsjahr in den Spotify Global Top-50 am 24.11.21:&quot;) + geom_text(aes(label = ..count..), stat = &quot;count&quot;, vjust = -0.2, colour = &quot;black&quot;) + labs(x= &quot;Erscheinungsjahr&quot;, y= &quot;Anzahl der Songs&quot;) release_year_plot Möchte ich nun wissen, welcher Song es ist, der in 1994 erschienen und dennoch in der heutigen Top-50 Playlist enthalten ist, kann ich dies über den folgenden Befehl erfahren: playlist_dataframe[playlist_dataframe$release_year==&quot;1994&quot;, c(&quot;track.name&quot;,&quot;main_artist&quot;)] ## # A tibble: 1 x 2 ## track.name main_artist ## &lt;chr&gt; &lt;chr&gt; ## 1 All I Want for Christmas Is You Mariah Carey 2.3.2 Audioanalysen In unserem Datensatz befinden sich mehrere Variablen aus den Audioanalysen, die Spotify für jeden einzelnen Song angefertigt hat und zudem im Empfehlungsalgorithmus verwendet. Dazu zählen neben dem Tempo (in Schläge pro Minute), der Tonart und der Taktart auch Werte für die folgenden Aspekte: Tanzbarkeit (danceability) auf einer Skala von 0 bis 1 Akustik (acousticness) auf einer Skala von 0 bis 1 Energie/Kraft (energy) auf einer Skala von 0 bis 1 Instrumentalität (instrumentalness) auf einer Skala von 0 bis 1 - wobei Songs mit Werten über 0.5 als Songs ohne Gesang/Rap vermutet werden Liveness auf einer Skala von 0 bis 1 - wobei ein höherer Wert für eine höhere Wahrscheinlichkeit steht, dass der Song live performed wurde Lautheit (loudness) in Dezibel, typischerweise zwischen -60 und 0 dB speechiness auf einer Skala von 0 bis 1 - als Indikator, ob sich im Song gesprochene Worte befinden Valenz (valence) auf einer Skala von 0 bis 1 - wobei ein höherer Wert für einen positiveren Klang steht Um ein paar dieser Aspekte zu untersuchen, bietet sich eine deskriptive Übersicht an. Dabei zeigt sich zum Beispiel, dass Songs in der Top-50 Global Playlist eine eher höhere Tanzbarkeit und eher niedrigere Werte für den Aspekt Akustik aufweisen. summary(playlist_dataframe[c(&quot;danceability&quot;, &quot;liveness&quot;, &quot;speechiness&quot;, &quot;valence&quot;, &quot;energy&quot;, &quot;acousticness&quot;,&quot;tempo&quot;)]) ## danceability liveness speechiness valence ## Min. :0.3320 Min. :0.02640 Min. :0.02820 Min. :0.0849 ## 1st Qu.:0.5745 1st Qu.:0.08843 1st Qu.:0.03895 1st Qu.:0.3100 ## Median :0.6675 Median :0.12000 Median :0.04985 Median :0.4645 ## Mean :0.6386 Mean :0.16306 Mean :0.08102 Mean :0.4779 ## 3rd Qu.:0.7522 3rd Qu.:0.17650 3rd Qu.:0.08785 3rd Qu.:0.6252 ## Max. :0.8700 Max. :0.46100 Max. :0.36300 Max. :0.9340 ## energy acousticness tempo ## Min. :0.1760 Min. :0.00146 Min. : 68.00 ## 1st Qu.:0.5068 1st Qu.:0.04000 1st Qu.: 98.64 ## Median :0.6420 Median :0.26650 Median :123.43 ## Mean :0.6082 Mean :0.31880 Mean :124.83 ## 3rd Qu.:0.7368 3rd Qu.:0.52100 3rd Qu.:148.97 ## Max. :0.8930 Max. :0.94600 Max. :179.95 Wir können uns nun beispielsweise anschauen, welche Songs in der Playlist die besonders hohen Werte für die Tanzbarkeit aufweisen. Erneut greifen wir dabei auf die Library ggplot2 zu, benutzen dieses Mal jedoch auch die Library dplyr, um unseren Datensatz gruppieren und filtern zu können. Den Filter setzen wir hier auf danceability &gt;= 0.75, um nur Ergebnisse für Songs zu erhalten, deren Tanzbarkeit mindestens 0.75 beträgt. Über die Funktionen labs() und ggtitle können wir unser Diagramm beschriften. Die Funktion theme() ermöglicht es uns, die Beschriftung der x-Achse für eine bessere Lesbarkeit um 90 Grad zu drehen. playlist_dataframe %&gt;% group_by(danceability) %&gt;% filter(danceability &gt;= 0.75) %&gt;% ggplot(aes(x = track.name, y = danceability)) + geom_col(aes(fill = track.name)) + labs(x= &quot;Songname&quot;, y= &quot;Danceability&quot;, fill= &quot;Songtitel&quot;) + ggtitle(&quot;Welche Songs in den Top-50 Global haben die höchste Tanzbarkeit?&quot;, &quot;Songs mit einer danceability &gt;= 0.75&quot;) + theme(axis.text.x = element_text(angle = 90)) Möchten wir uns nun anschauen, welche Tonarten in der Playlist vertreten sind, können wir dies mit der Variable key_mode und der Funktion ggplot(). key_plot &lt;- ggplot(playlist_dataframe, aes(x=key_mode)) + geom_bar() + labs(title = &quot;Anzahl der Songs nach Tonart in den Spotify Global Top-50 am 24.11.21:&quot;) + geom_text(aes(label = ..count..), stat = &quot;count&quot;, vjust = -0.2, colour = &quot;black&quot;) + labs(x= &quot;Tonart&quot;, y= &quot;Anzahl der Songs&quot;) + theme(axis.text.x = element_text(angle = 90)) key_plot In vielen Fällen sind die Songs in einer Playlist aufeinander abgestimmt, beispielsweise um ein Genre (Rap Caviar, Electronic Rising, Dance Brandneu), einen Anlass (Partyhymnen, Christmas Hits), eine bestimmte Zeit (All Out 90s) oder Ähnliches abzubilden. Ob bewusst oder unbewusst, meistens entscheiden wir uns doch für Playlisten aufgrund ihrer Stimmung. Möchten wir nun wissen, welchen Stimmungen sich die Songs einer Playlist zuordnen lassen und so vielleicht auch mehr über unsere persönlichen Präferenzen herausfinden, können wir die Variablen energy und valence aus den Audioanalysen verwenden. Spotify defininert die beiden Variablen wie folgt: Valence: A measure from 0.0 to 1.0 describing the musical positiveness conveyed by a track. Tracks with high valence sound more positive (e.g. happy, cheerful, euphoric), while tracks with low valence sound more negative (e.g. sad, depressed, angry). Energy: Energy is a measure from 0.0 to 1.0 and represents a perceptual measure of intensity and activity. Typically, energetic tracks feel fast, loud, and noisy. For example, death metal has high energy, while a Bach prelude scores low on the scale. Perceptual features contributing to this attribute include dynamic range, perceived loudness, timbre, onset rate, and general entropy. Mit diesen beiden Variablen können wir also ein Streudiagramm erstellen und in Quadranten einteilen. Dabei können wir festlegen, dass wir Songs mit hoher Valenz (happy, cheerful, euphoric) und hoher Energie (fast, loud, and noisy) als Joyful / Happy bezeichnen würden, während Songs mit niedriger Valenz (sad, depressed, angry) und niedriger Energie eher Depressing / Sad beschrieben werden können. Songs mit einer hohen Energie, aber einer niedrigen Valenz können wir als Angry / Turbulent und Songs mit einer niedrigen Energie, aber hohen Valenz als Peace / Chill beschreiben. Mit dem folgenden Code erhalten wir einen emotionalen Quadranten, der uns Aufschluss über die Stimmung unserer ausgewählten Playlist gibt. emotionalQuadrant &lt;- ggplot(data = playlist_dataframe, aes(x = valence, y = energy)) + geom_jitter(size = 0.8) + geom_vline(xintercept = 0.5) + geom_hline(yintercept = 0.5) + scale_x_continuous(expand = c(0, 0), limits = c(0, 1)) + scale_y_continuous(expand = c(0, 0), limits = c(0, 1)) + annotate(&#39;text&#39;, 0.25 / 2, 0.95, label = &quot;Angry / Turbulent&quot;) + annotate(&#39;text&#39;, 1.75 / 2, 0.95, label = &quot;Joyful / Happy&quot;) + annotate(&#39;text&#39;, 1.75 / 2, 0.05, label = &quot;Peace / Chill&quot;) + annotate(&#39;text&#39;, 0.25 / 2, 0.05, label = &quot;Depressing / Sad&quot;) + labs(x= &quot;Valence&quot;, y= &quot;Energy&quot;) + ggtitle(&quot;Emotional quadrant of chosen playlist&quot;, &quot;Based on energy and valence&quot;) emotionalQuadrant 3 Artist Analysen Für Daten zu Künstlern bietet spotifyr ebenfalls eine Vielzahl an Funktionen. Diese umfassen unter anderem: get_artist_audio_features() - für die Audio-Analysen der gesamten Diskographie get_artist_albums() - für Meta-Informationen des Katalogs get_artist_top_tracks() - für die Top-Songs des Künstlers innerhalb eines bestimmten Marktes/Land get_related_artists() - für Informationen über ähnliche Künstler, basierend auf dem vergangenen Hörverhalten der Spotify-Nutzer 3.1 Related Artists Um zu untersuchen, welche Artists basierend auf dem Hörverhalten der Spotify-Nutzer mit einem von uns gewählten Artists in Verbindung stehen, benötigen wir lediglich die ID des Artists. Diese können wir entweder wie bei den Playlisten aus dem Link des Artistprofils über Spotify kopieren oder sie aus den artist audio features ziehen, für die wir lediglich den Namen benötigen. Wir können also die Funktion get_artist_audio_features() auf einen beliebigen Namen anwenden und die Spalte artist_id abrufen. Da unser Datensatz artist_data jedoch aus allen Songs des Artists besteht und wir die ID nur einmal benötigen, müssen wir durch die Erweiterung [1] den Eintrag in der ersten Zeile wählen. artist_data &lt;- get_artist_audio_features(artist= c(&quot;Travis Scott&quot;)) artist_data$artist_id[1] ## [1] &quot;0Y5tJX1MQlPlqiwlOH1tJY&quot; Nun können wir die artist_id für die Funktion get_related_artists() nutzen und erhalten einen Datensatz mit Informationen zu den aufgrund von Nutzungsdaten der Spotify-User ähnlichen Künstlern. related_artists &lt;- get_related_artists( artist_data$artist_id[1], include_meta_info = FALSE ) related_artists$name ## [1] &quot;A$AP Rocky&quot; &quot;Chief Keef&quot; &quot;Joey Bada$$&quot; ## [4] &quot;A$AP Ferg&quot; &quot;Huncho Jack&quot; &quot;Pusha T&quot; ## [7] &quot;Kendrick Lamar&quot; &quot;A$AP Mob&quot; &quot;Chance the Rapper&quot; ## [10] &quot;ScHoolboy Q&quot; &quot;Meek Mill&quot; &quot;Playboi Carti&quot; ## [13] &quot;Quavo&quot; &quot;Childish Gambino&quot; &quot;2 Chainz&quot; ## [16] &quot;Metro Boomin&quot; &quot;Frank Ocean&quot; &quot;Flatbush Zombies&quot; ## [19] &quot;Big Sean&quot; &quot;Jaden&quot; Aus unserem neuen related_artists Datensatz können wir zudem die popularity der Künstler entnehmen und mit dem folgenden Code vergleichbar darstellen. related_artists_plot &lt;- ggplot(related_artists, aes(x=name, y=popularity)) + geom_bar(stat = &quot;identity&quot;) + # Y axis is explicit. &#39;stat=identity&#39; geom_col(aes(fill = name), show.legend = FALSE) + labs(x= &quot;Artist&quot;, y= &quot;Popularity&quot;) + ggtitle(&quot;Wie populär sind Künstler die Spotify mit Travis Scott assoziiert?&quot;,&quot;Basierend auf dem Hörverhalten der Spotify User&quot;) + theme(axis.text.x = element_text(angle = 90)) related_artists_plot 3.2 Artist Vergleich Möchten wir nun beliebig viele Artists mit Hilfe der Funktion get_artist_audio_features miteinander vergleichen, können wir uns einfach eine Liste beliebiger Artists erstellen und die Funktion in einer for-Schleife anwenden. Vor der Schleife generieren wir zunächst einen leeren Datensatz mit dem Namen artist_comparison. In der for-Schleife führen wir dann solange die folgenden Aktionen durch, bis jeder Eintrag in unserer artist_names-Liste verwendet worden ist. Mit dem Befehl for (i in 1:length(artist_names)) sagen wir also, dass die darauf folgenden Aktionen für jede Nummer i in dem Intervall von 1 bis 5 (also der Anzahl der Einträge in unserer artist_names Liste) durchgeführt werden sollen. Die Aktionen, die wir dann für jede Nummer von 1 bis 5 durchführen umfassen: die Erstellung des Datensatzes artist_data mit der Funktion get_artist_audio_features für den jeweiligen Artist aus unserer Liste das Zusammenfügen unseres artist_comparison Datensatzes mit dem neuen artist_data Datensatz das Ausgeben des Künstlernamens des im jeweiligen Durchlauf verwendeten Artists. Diese Ausgabe dient nur zu dem Zweck, den Fortschritt unserer Schleife zu überprüfen Zusammengefasst nimmt unsere for-Schleife also jedes Mal einen Artistnamen, verwendet ihn für die get_artist_audio_features Funktion und fügt die neuen künstlerspezifischen Daten unserem gesamten artist_comparison Datensatz hinzu. artist_names &lt;- c(&quot;Adele&quot;,&quot;The Weeknd&quot;, &quot;Billie Eilish&quot;, &quot;Skrillex&quot;, &quot;Dua Lipa&quot;) artist_comparison &lt;- data.frame() for (i in 1:length(artist_names)) { artist_data &lt;- get_artist_audio_features(artist= artist_names[i]) artist_comparison &lt;- rbind(artist_comparison, artist_data) print(artist_names[i]) } ## [1] &quot;Adele&quot; ## [1] &quot;The Weeknd&quot; ## [1] &quot;Billie Eilish&quot; ## [1] &quot;Skrillex&quot; ## Request failed [429]. Retrying in 1 seconds... ## Request failed [429]. Retrying in 1 seconds... ## [1] &quot;Dua Lipa&quot; Nun können wir wie zuvor bei den Playlisten verschiedene Analysen zu den von uns gewählten Artists durchführen. So können wir beispielsweise erneut einen emotionalen Qudaranten erstellen und diesmal farblich zwischen den Artists unterscheiden. emotionalQuadrant_top_artists &lt;- ggplot(data = artist_comparison, aes(x = valence, y = energy, color = artist_name)) + geom_jitter(size = 0.8) + geom_vline(xintercept = 0.5) + geom_hline(yintercept = 0.5) + scale_x_continuous(expand = c(0, 0), limits = c(0, 1)) + scale_y_continuous(expand = c(0, 0), limits = c(0, 1)) + annotate(&#39;text&#39;, 0.25 / 2, 0.95, label = &quot;Angry / Turbulent&quot;) + annotate(&#39;text&#39;, 1.75 / 2, 0.95, label = &quot;Joyful / Happy&quot;) + annotate(&#39;text&#39;, 1.75 / 2, 0.05, label = &quot;Peace / Chill&quot;) + annotate(&#39;text&#39;, 0.25 / 2, 0.05, label = &quot;Depressing / Sad&quot;) + labs(x= &quot;Valence&quot;, y= &quot;Energy&quot;, color = &quot;Artist&quot;) + ggtitle(&quot;Emotional quadrant of selected artists&quot;, &quot;Based on energy and valence&quot;) emotionalQuadrant_top_artists 4 Album Analysen Eine weitere Möglichkeit die uns das spotifyr Package bietet ist die Analyse von Alben. Hierzu können unter anderem folgende Funktionen genutzt werden: get_artist_albums - Um den Katalog eines oder mehrerer Artists zu erhalten get_albums - Um Informationen zu Alben mithilfe ihrer ID zu erhalten get_album_tracks - Um Informationen zu den Songs innerhalb bestimmter Alben zu erhalten 4.1 Album Vergleich Durch eine Kombination der Funktionen get_album_tracks und get_track_audio_features können wir so beispielsweise Alben anhand der Audio-Features der enthaltenen Tracks vergleichen. Vergleichen wir als Beispiel mal das Album Astroworld von Travis Scott mit dem Album Views von Drake. Im Folgenden erstellen wir also zunächst über get_album_tracks einen Datensatz mit Informationen über die Songs im Album Astroworld von Travis Scott anhand der URI des Albums. Wir nennen diesen Datensatz astroworld_tracks. Anschließend erstellen wir einen Datensatz mit dem Titel astroworld und benutzen eine for-Schleife, um ihn mit den Audio-Features der Songs, die wir durch die Funktion get_track_audio_features und die ID der Songs befüllen können. Die ID der Songs befindet sich logischerweise in der Spalte ID in unserem astroworld_tracks Datensatz. astroworld_tracks &lt;- get_album_tracks(&quot;41GuZcammIkupMPKH2OJ6I&quot;) astroworld &lt;-data.frame() for (i in 1:nrow(astroworld_tracks)) { track_data &lt;- get_track_audio_features(astroworld_tracks$id[i]) astroworld &lt;- rbind(astroworld, track_data) } Um die Tracks später in einem Datensatz mit unserem zweiten Album weiterhin Astroworld zuordnen zu können, fügen wir noch eine Spalte mit dem Namen album und dem Eintrag \"Astroworld hinzu. astroworld$album &lt;- &quot;Astroworld&quot; Nun wiederholen wir die Schritte für das Album Views. Hierfür benötigen wir erneut nur die URI des Albums. views_tracks &lt;- get_album_tracks(&quot;40GMAhriYJRO1rsY4YdrZb&quot;) views &lt;-data.frame() for (i in 1:nrow(views_tracks)) { track_data &lt;- get_track_audio_features(views_tracks$id[i]) views &lt;- rbind(views, track_data) } Auch unseren views Datensatz müssen wir noch entsprechend des Albumtitels labeln. views$album &lt;- &quot;Views&quot; Anschließend können wir die beiden Album-Datensätze zu einem neuen Datensatz mit dem Titel album_comparison vereinen. album_comparison &lt;- rbind(astroworld, views) Die von uns hinzugefügten album Spalten, ermöglichen es uns nun die Audio-Features der Alben zu vergleichen. So wie im Kapitel 2.3.2 Audioanalysen stehen uns dafür verschiedene Variablen wie energy oder valence zur Verfügung. So können wir zum Beispiel erneut einen emotional Quadrant anfertigen und die Stimmung der Songs unserer Alben vergleichen. emotionalQuadrant &lt;- ggplot(data = album_comparison, aes(x = valence, y = energy, color = album)) + geom_jitter() + geom_vline(xintercept = 0.5) + geom_hline(yintercept = 0.5) + scale_x_continuous(expand = c(0, 0), limits = c(0, 1)) + scale_y_continuous(expand = c(0, 0), limits = c(0, 1)) + annotate(&#39;text&#39;, 0.25 / 2, 0.95, label = &quot;Angry / Turbulent&quot;) + annotate(&#39;text&#39;, 1.75 / 2, 0.95, label = &quot;Joyful / Happy&quot;) + annotate(&#39;text&#39;, 1.75 / 2, 0.05, label = &quot;Peace / Chill&quot;) + annotate(&#39;text&#39;, 0.25 / 2, 0.05, label = &quot;Depressing / Sad&quot;) + labs(x= &quot;Valence&quot;, y= &quot;Energy&quot;) + ggtitle(&quot;Emotional comparison of Travis Scott - Astroworld and Drake - Views&quot;, &quot;Based on energy y valence&quot;) emotionalQuadrant 5 Weitere Ressourcen Hilfestellungen / Dokumentationen: Spotify API Dokumentation Spotifyr Package Dokumentation Ursprünglicher towards data science Artikel zur Spotify API / spotifyr - Inspiration für dieses Tutorial Weitere Learnings/Tutorials: Introduction to Accessing Spotify API in R Hackathon Talk “Audio Analysis with the Spotify Web API” - beinhaltet auch Hintergrundinformationen zu den Berehcnungen der Audioanalyse-Features "]]
